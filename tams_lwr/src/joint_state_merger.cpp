/* joint_state_merger.cpp
 *
 * This node subscribes to joint_state messages generated by the
 * several sub-components of the domestic robot (Scitos G5, LWR Jaco,
 * PTU, ...), merges the data, and publishes the global /joint_state
 * messages expected by tf and the rest of ROS.
 *
 * 06.01.2015 - support old/new kinova_jaco
 * 22.09.2014 - don't NPE when no velocities/efforts in incoming JointState
 * 22.07.2013 - add missing pthread_mutex_init
 * 06.12.2012 - use params to configure the node, log the values
 * 05.12.2012 - new class
 *
 * (C) 2012 fnh, hendrich@informatik.uni-hamburg.de
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <pthread.h>
#include <unistd.h>

#include <ros/ros.h>
#include <sensor_msgs/JointState.h>

/**
 * A ROS node that subscribes to the /joint_state messages
 * generated by several subcomponents of our robot setup,
 * merges the data, and re-publishes to the global /joint_state
 * topic expected by tf and the rest of ROS.
 * Parameters are:
   publish_rate        : in Hz, default is 100 Hz
   joint_state_topic   : the merged published /joint_states
   lwr_joint_topic     : where to subscribe to LWR joint angles
   wsg_joint_topic     : where to subscribe to WSG joint angles
   scitos_topic        : where to subscribe to Scitos wheel data
 * To configure the node via rosrun, use the following syntax,
 * where the underscore's specify the node's private namespace:
   rosrun tams_utilities joint_state_merger _publish_rate:=77.3
 */
class JointStateMerger
{
public:
    JointStateMerger();

    void lwrUpdatedCallback(const sensor_msgs::JointState lwrJointState);
    void wsgUpdatedCallback(const sensor_msgs::JointState wsgJointState);
    void scitosUpdatedCallback(const sensor_msgs::JointState scitosWheelState);
    void timerCallback(const ros::TimerEvent&);

private:
    void initializeJointStuff();

    ros::NodeHandle nh;
    ros::Subscriber lwrJointStateSubscriber;
    ros::Subscriber wsgJointStateSubscriber;
    ros::Subscriber scitosWheelStateSubscriber;
    ros::Publisher jointStatePublisher;
    ros::Timer timer;

    std::vector<std::string> jointNames;       // global joint names
    std::vector<double> jointAngles;           // angle in radians
    std::vector<double> jointVelocities;       // radians per second
    std::vector<double> jointTorques;          // newton-meters
    std::map<std::string, int> jointIndexMap;  // name -> index

    unsigned int n_lwr_callbacks;
    unsigned int n_wsg_callbacks;
    unsigned int n_scitos_callbacks;
    unsigned int n_timer_callbacks;

    double rate;

    pthread_mutex_t mutex;

    static constexpr double RAD2DEG = 180.0 / M_PI;
    static constexpr double DEG2RAD = M_PI / 180.0;
};  // end class declaration

/**
 * construct a JointStateMerger.
 */
JointStateMerger::JointStateMerger()
{
    n_lwr_callbacks = n_scitos_callbacks = n_wsg_callbacks = 0;
    n_timer_callbacks = 0;

    pthread_mutex_init(&mutex, NULL);  // default attributes

    std::string lwrJointTopic = "lwr/joint_states";
    std::string wsgJointTopic = "wsg_50/joint_states";
    std::string scitosTopic = "scitos/wheel_states";
    std::string jointStateTopic = "joint_states";

    // FIXME: I still don't really understand the private namespace thingy...
    ros::NodeHandle nnh("~");
    nnh.param("publish_rate", rate, 100.0);  // default 100 Hz
    nnh.param("joint_state_topic", jointStateTopic, jointStateTopic);
    nnh.param("lwr_joint_topic", lwrJointTopic, lwrJointTopic);
    nnh.param("wsg_joint_topic", wsgJointTopic, wsgJointTopic);
    nnh.param("scitos_topic", scitosTopic, scitosTopic);

    initializeJointStuff();

    lwrJointStateSubscriber =
        nh.subscribe<sensor_msgs::JointState>(lwrJointTopic.c_str(), 1, &JointStateMerger::lwrUpdatedCallback, this);

    scitosWheelStateSubscriber =
        nh.subscribe<sensor_msgs::JointState>(scitosTopic.c_str(), 1, &JointStateMerger::scitosUpdatedCallback, this);

    wsgJointStateSubscriber =
        nh.subscribe<sensor_msgs::JointState>(wsgJointTopic, 1, &JointStateMerger::wsgUpdatedCallback, this);

    jointStatePublisher = nh.advertise<sensor_msgs::JointState>(jointStateTopic.c_str(), 1);

    timer = nh.createTimer(ros::Duration(1.0 / rate), &JointStateMerger::timerCallback, this);

    ROS_INFO("DJSM JointStateMerger initialized:");
    ROS_INFO("DJSM publishing at %5.1f Hz to '%s'", rate, jointStateTopic.c_str());
    ROS_INFO("DJSM lwr_joint_topic '%s'", lwrJointTopic.c_str());
    ROS_INFO("DJSM wsg_joint_topic '%s'", wsgJointTopic.c_str());
    ROS_INFO("DJSM scitos_topic '%s'", scitosTopic.c_str());
}

/**
 * initializes the jointNames array and zeroes the jointAngles,
 * jointVelocities, jointTorques, and targetAngles arrays.
 */
void JointStateMerger::initializeJointStuff()
{
    jointNames.push_back("lwr_arm_0_joint");
    jointNames.push_back("lwr_arm_1_joint");
    jointNames.push_back("lwr_arm_2_joint");
    jointNames.push_back("lwr_arm_3_joint");
    jointNames.push_back("lwr_arm_4_joint");
    jointNames.push_back("lwr_arm_5_joint");
    jointNames.push_back("lwr_arm_6_joint");

    jointNames.push_back("wsg_50_gripper_base_joint_gripper_left");
    jointNames.push_back("wsg_50_gripper_base_joint_gripper_right");

    // jointNames.push_back( "left_wheel_joint" );
    // jointNames.push_back( "right_wheel_joint" );

    for (unsigned int i = 0, N = jointNames.size(); i < N; i++)
    {
        jointIndexMap[jointNames[i]] = i;  // name -> index into jointNames
    }

    for (unsigned int i = 0, N = jointNames.size(); i < N; i++)
    {
        jointAngles.push_back(0.0);
        jointVelocities.push_back(0.0);
        jointTorques.push_back(0.0);
    }
}  // initializeJointStuff

/**
 * called when Kinova/Gazebo publishes new position/velocity/torque data for the
 * LWR arm. Position data is in radians, velocity in radians/second,
 * and torque data is in newton-meters.
 */
void JointStateMerger::lwrUpdatedCallback(const sensor_msgs::JointState jointState)
{
    // if (debug) ROS_INFO( "DJSM.lwrUpdatedCallback %p", &jointState );
    n_lwr_callbacks++;
    if (n_lwr_callbacks < 5)
    {
        ROS_INFO("DJSM.lwrUpdatedCallback %p", &jointState);
    }

    pthread_mutex_lock(&mutex);

    unsigned int matched_lwr_joints = 0;
    for (unsigned int i = 0; i < jointState.name.size(); i++)
    {
        std::string name = jointState.name[i];
        int found = jointIndexMap.count(name);
        if (found > 0)
        {
            int jointIndex = jointIndexMap[name];  // 0..5 for S1..W2
            jointAngles[jointIndex] = jointState.position[i];

            // some software doesn't include velocity and effort, ...
            // check here to avoid NPE...
            if (jointState.velocity.size() == jointState.name.size())
                jointVelocities[jointIndex] = jointState.velocity[i];
            else
                jointVelocities[jointIndex] = NAN;

            if (jointState.effort.size() == jointState.name.size())
                jointTorques[jointIndex] = jointState.effort[i];
            else
                jointTorques[jointIndex] = NAN;

            matched_lwr_joints++;
        }
    }
    if (matched_lwr_joints != 7)
    {
        ROS_INFO("DJSM.lwrUpdatedCallback: invalid/incomplete jointState,");
        ROS_INFO("DJSM... only matched %d LWR joints.", matched_lwr_joints);
    }
    pthread_mutex_unlock(&mutex);
}

/**
 * called when Cognidrive publishes new wheel data for the Scitos G5
 * robot platform.
 * Jaco arm. Position data is in radians, velocity in radians/second,
 * and torque data is in newton-meters.
 */
void JointStateMerger::scitosUpdatedCallback(const sensor_msgs::JointState jointState)
{
    // if (debug) ROS_INFO( "DJSM.scitosUpdatedCallback %p", &jointState );
    n_scitos_callbacks++;
    if (n_scitos_callbacks < 5)
    {
        ROS_INFO("DJSM.scitosUpdatedCallback %p", &jointState);
    }
    pthread_mutex_lock(&mutex);

    unsigned int matched_wheel_joints = 0;
    for (unsigned int i = 0; i < jointState.name.size(); i++)
    {
        std::string name = jointState.name[i];
        int found = jointIndexMap.count(name);
        if (found > 0)
        {
            int wheelIndex = jointIndexMap[name];
            jointAngles[wheelIndex] = jointState.position[i];
            jointVelocities[wheelIndex] = jointState.velocity[i];
            jointTorques[wheelIndex] = jointState.effort[i];
        }
    }

    if (matched_wheel_joints != 2)
    {
        ROS_INFO("DJSM.scitosUpdatedCallback: invalid/incomplete jointState,");
        ROS_INFO("DJSM... only matched %d wheels.", matched_wheel_joints);
    }

    pthread_mutex_unlock(&mutex);
}  // scitosUpdatedCallback

/**
 * called when the PTU publishes new pan/tilt data.
 */
void JointStateMerger::wsgUpdatedCallback(const sensor_msgs::JointState jointState)
{
    // if (debug) ROS_INFO( "DJSM.wsgUpdatedCallback %p", &jointState );
    n_wsg_callbacks++;
    if (n_wsg_callbacks < 5)
    {
        ROS_INFO("DJSM.wsgUpdatedCallback %p", &jointState);
    }

    pthread_mutex_lock(&mutex);

    unsigned int matched_wsg_joints = 0;
    for (unsigned int i = 0; i < jointState.name.size(); i++)
    {
        std::string name = jointState.name[i];
        int found = jointIndexMap.count(name);
        if (found > 0)
        {
            int wsgIndex = jointIndexMap[name];
            jointAngles[wsgIndex] = jointState.position[i];

            if (jointState.velocity.size() == jointState.name.size())
                jointVelocities[wsgIndex] = jointState.velocity[i];
            else
                jointVelocities[wsgIndex] = NAN;

            if (jointState.effort.size() == jointState.name.size())
                jointTorques[wsgIndex] = jointState.effort[i];
            else
                jointTorques[wsgIndex] = NAN;
            matched_wsg_joints++;
        }
    }

    if (matched_wsg_joints != 2)
    {
        ROS_INFO("DJSM.wsgUpdatedCallback: invalid/incomplete jointState,");
        ROS_INFO("DJSM... only matched %d PTU joints.", matched_wsg_joints);
    }
    pthread_mutex_unlock(&mutex);
}

/**
 * called by our internal timer. We take the latest values received
 * from the different components, and publish our /joint_state message.
 */
void JointStateMerger::timerCallback(const ros::TimerEvent& timerEvent)
{
    // TimerEvent :->  Time ->sec,nscec
    n_timer_callbacks++;
    if ((n_timer_callbacks < 5) || ((n_timer_callbacks % (60 * 100)) == 0))
    {  // once per minute at 100Hz
        ROS_INFO("SJM timerCallback at %d, %d", timerEvent.current_real.sec, n_timer_callbacks);
    }

    unsigned int N = jointNames.size();
    sensor_msgs::JointState jsmsg;
    jsmsg.header.seq = n_timer_callbacks;
    jsmsg.header.stamp = ros::Time::now();
    jsmsg.header.frame_id = std::string("lwr_with_wsg50");

    jsmsg.name.resize(N);
    jsmsg.position.resize(N);
    jsmsg.velocity.resize(N);
    jsmsg.effort.resize(N);
    for (unsigned int i = 0; i < N; i++)
    {
        jsmsg.name[i] = jointNames[i];
        jsmsg.position[i] = jointAngles[i];
        jsmsg.velocity[i] = jointVelocities[i];
        jsmsg.effort[i] = jointTorques[i];
    }
    jointStatePublisher.publish(jsmsg);
}

/**
 * starts the joint-state merger.
 */
int main(int argc, char** argv)
{
    ros::init(argc, argv, "joint_state_merger", 1);  // 1 means no NoSigintHandler
    // ros::init_options::InitOption.NoSigintHandler );

    JointStateMerger merger = JointStateMerger();

    ROS_INFO("DJSM entering spin()...");

    ros::spin();
    exit(0);
}
