/* doro_watchdog.cpp
 *
 * A watchdog node that checks correct function of the Robot-Era
 * Domestic robot ("Doro") in Gazebo simulation.
 *
 * The node expects that Gazebo is running and that the platform
 * differential drive controller, the head PTU controller, and
 * the Jaco arm controllers are loaded and running.
 *
 * Checks performed by the node at runtime include
   - observation of the Jaco arm trajectory tracking error
   - observation of the Jaco fingers tracking error
   - observation of the pan-tilt unit tracking error
   - presumed self-collisions of the robot using FK/IK and MoveIt.

 * The node subscribes to:
   doro/joint_states
   doro/jaco_arm_controller/state
   doro/jaco_finger_joint_1_controller/state
   doro/jaco_finger_joint_1_controller/state
   doro/jaco_finger_joint_1_controller/state
   doro/ptu_controller/state

 * Diagnostic messages are printed to ROS_INFO, ROS_WARN, and ROS_ERROR,
 * and status is also published to
   doro/watchdog/messages

 * This node subscribes to joint_state messages generated by the
 * several sub-components of the domestic robot (Scitos G5, Jaco,
 * PTU, ...), merges the data, and publishes the global /joint_state
 * messages expected by tf and the rest of ROS.
 *
 * 13.01.2015 - new class
 *
 * (C) 2015 fnh, hendrich@informatik.uni-hamburg.de
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>
#include <pthread.h>

#include <sstream>

#include <ros/ros.h>
#include <std_msgs/String.h>
#include <sensor_msgs/JointState.h>
#include <control_msgs/JointTrajectoryControllerState.h>

#undef ORIG_KINOVA_JACO  // kinova_jaco: jaco_shoulder_yaw_joint  vs. JacoROS jaco_joint_1 etc.

/**
 * A ROS node to check correct operation of the Domestic Robot.
 */
class DoroWatchdog
{
public:
    DoroWatchdog();

    void jointsUpdatedCallback(const sensor_msgs::JointState jointState);
    void ptuUpdatedCallback(const sensor_msgs::JointState ptuJointState);

    void armControllerStateCallback(const control_msgs::JointTrajectoryControllerState controllerState);
    void finger1ControllerStateCallback(const control_msgs::JointTrajectoryControllerState controllerState);
    void finger2ControllerStateCallback(const control_msgs::JointTrajectoryControllerState controllerState);
    void finger3ControllerStateCallback(const control_msgs::JointTrajectoryControllerState controllerState);
    void ptuControllerStateCallback(const control_msgs::JointTrajectoryControllerState controllerState);

    // void scitosUpdatedCallback( const sensor_msgs::JointState scitosWheelState );
    void timerCallback(const ros::TimerEvent&);

private:
    void initializeJointStuff();

    ros::NodeHandle nh;
    ros::Subscriber jointStateSubscriber;
    ros::Subscriber ptuControllerSubscriber;
    ros::Subscriber armControllerSubscriber;
    ros::Subscriber finger1ControllerSubscriber;
    ros::Subscriber finger2ControllerSubscriber;
    ros::Subscriber finger3ControllerSubscriber;

    ros::Publisher diagnosticPublisher;
    ros::Timer timer;

    std::string prefix;
    std::vector<std::string> jointNames;       // global joint names
    std::vector<double> jointAngles;           // angle in radians
    std::vector<double> jointVelocities;       // radians per second
    std::vector<double> jointTorques;          // newton-meters
    std::map<std::string, int> jointIndexMap;  // name -> index

    unsigned int n_joint_state_callbacks;
    unsigned int n_ptu_controller_callbacks;
    unsigned int n_arm_controller_callbacks;
    unsigned int n_finger1_controller_callbacks;
    unsigned int n_finger2_controller_callbacks;
    unsigned int n_finger3_controller_callbacks;
    unsigned int n_timer_callbacks;

    double rate;

    pthread_mutex_t mutex;

    static const double RAD2DEG = 180.0 / M_PI;
    static const double DEG2RAD = M_PI / 180.0;
};  // end class declaration

/**
 * construct a DoroWatchdog.
 */
DoroWatchdog::DoroWatchdog()
{
    prefix = "doro/";

    n_joint_state_callbacks = 0;
    n_ptu_controller_callbacks = 0;
    n_arm_controller_callbacks = 0;
    n_finger1_controller_callbacks = 0;
    n_finger2_controller_callbacks = 0;
    n_finger3_controller_callbacks = 0;
    n_timer_callbacks = 0;

    pthread_mutex_init(&mutex, NULL);  // default attributes

    ros::NodeHandle nnh("~");
    nnh.param("publish_rate", rate, 100.0);  // default 100 Hz
    initializeJointStuff();

    jointStateSubscriber =
        nh.subscribe<sensor_msgs::JointState>("joint_states", 1, &DoroWatchdog::jointsUpdatedCallback, this);

    armControllerSubscriber = nh.subscribe<control_msgs::JointTrajectoryControllerState>(
        "jaco_arm_controller/state", 1, &DoroWatchdog::armControllerStateCallback, this);

    finger1ControllerSubscriber = nh.subscribe<control_msgs::JointTrajectoryControllerState>(
        "jaco_finger_joint_1_controller/state", 1, &DoroWatchdog::finger1ControllerStateCallback, this);

    finger2ControllerSubscriber = nh.subscribe<control_msgs::JointTrajectoryControllerState>(
        "jaco_finger_joint_2_controller/state", 1, &DoroWatchdog::finger1ControllerStateCallback, this);

    finger3ControllerSubscriber = nh.subscribe<control_msgs::JointTrajectoryControllerState>(
        "jaco_finger_joint_3_controller/state", 1, &DoroWatchdog::finger1ControllerStateCallback, this);

    ptuControllerSubscriber = nh.subscribe<control_msgs::JointTrajectoryControllerState>(
        "ptu_trajectory_controller/state", 1, &DoroWatchdog::ptuControllerStateCallback, this);

    diagnosticPublisher = nh.advertise<std_msgs::String>("messages", 1);

    timer = nh.createTimer(ros::Duration(1.0 / rate), &DoroWatchdog::timerCallback, this);

    ROS_INFO("DJSM DoroWatchdog initialized:");
}

/**
 * initializes the jointNames array and zeroes the jointAngles,
 * jointVelocities, jointTorques, and targetAngles arrays.
 */
void DoroWatchdog::initializeJointStuff()
{
#ifdef ORIG_KINOVA_JACO
    jointNames.push_back(prefix + "jaco_shoulder_yaw_joint");
    jointNames.push_back(prefix + "jaco_shoulder_pitch_joint");
    jointNames.push_back(prefix + "jaco_elbow_pitch_joint");
    jointNames.push_back(prefix + "jaco_elbow_roll_joint");
    jointNames.push_back(prefix + "jaco_wrist_roll_joint");
    jointNames.push_back(prefix + "jaco_hand_roll_joint");
    jointNames.push_back(prefix + "jaco_finger_1_joint");
    jointNames.push_back(prefix + "jaco_finger_2_joint");
    jointNames.push_back(prefix + "jaco_finger_3_joint");
#else  // JacoROS
    jointNames.push_back(prefix + "jaco_joint_1");
    jointNames.push_back(prefix + "jaco_joint_2");
    jointNames.push_back(prefix + "jaco_joint_3");
    jointNames.push_back(prefix + "jaco_joint_4");
    jointNames.push_back(prefix + "jaco_joint_5");
    jointNames.push_back(prefix + "jaco_joint_6");
    jointNames.push_back(prefix + "jaco_finger_joint_1");
    jointNames.push_back(prefix + "jaco_finger_joint_2");
    jointNames.push_back(prefix + "jaco_finger_joint_3");
#endif

    jointNames.push_back("ptu_pan_joint");
    jointNames.push_back("ptu_tilt_joint");

    jointNames.push_back("left_wheel_joint");
    jointNames.push_back("right_wheel_joint");

    for (unsigned int i = 0, N = jointNames.size(); i < N; i++)
    {
        jointIndexMap[jointNames[i]] = i;  // name -> index into jointNames
    }

    for (unsigned int i = 0, N = jointNames.size(); i < N; i++)
    {
        jointAngles.push_back(0.0);
        jointVelocities.push_back(0.0);
        jointTorques.push_back(0.0);
    }
}  // initializeJointStuff

/**
 * called when we receive the full JointState message from Gazebo.
 * Position data is in radians, velocity in radians/second,
 * and torque data is in newton-meters.
 */
void DoroWatchdog::jointsUpdatedCallback(const sensor_msgs::JointState jointState)
{
    // if (debug) ROS_INFO( "DJSM.jacoUpdatedCallback %p", &jointState );
    n_joint_state_callbacks++;
    if (n_joint_state_callbacks < 5)
    {
        ROS_INFO("DJSM.jointsUpdatedCallback %p", &jointState);
    }

    pthread_mutex_lock(&mutex);

    unsigned int matched_jaco_joints = 0;
    for (unsigned int i = 0; i < jointState.name.size(); i++)
    {
        std::string name = jointState.name[i];
        int found = jointIndexMap.count(name);
        if (found > 0)
        {
            int jointIndex = jointIndexMap[name];  // 0..5 for S1..W2
            jointAngles[jointIndex] = jointState.position[i];

            // some software doesn't include velocity and effort, ...
            // check here to avoid NPE...
            if (jointState.velocity.size() == jointState.name.size())
                jointVelocities[jointIndex] = jointState.velocity[i];
            else
                jointVelocities[jointIndex] = NAN;

            if (jointState.effort.size() == jointState.name.size())
                jointTorques[jointIndex] = jointState.effort[i];
            else
                jointTorques[jointIndex] = NAN;

            matched_jaco_joints++;
        }
    }
    if (matched_jaco_joints != 9)
    {
        ROS_INFO("DJSM.jacoUpdatedCallback: invalid/incomplete jointState,");
        ROS_INFO("DJSM... only matched %d Jaco joints.", matched_jaco_joints);
    }
    pthread_mutex_unlock(&mutex);
}

/**
 * called when the PTU trajectory controller publishes new state data.
 */
void DoroWatchdog::ptuControllerStateCallback(const control_msgs::JointTrajectoryControllerState ptuState)
{
    // if (debug) ROS_INFO( "DJSM.ptuUpdatedCallback %p", &jointState );
    n_ptu_controller_callbacks++;
    if (n_ptu_controller_callbacks < 5)
    {
        ROS_INFO("DJSM.ptuUpdatedCallback %p", &ptuState);
    }

    pthread_mutex_lock(&mutex);

    double ptu_err_threshold = 0.02;
    double err_pan_position = ptuState.error.positions[0];
    double err_tilt_position = ptuState.error.positions[1];

    if ((fabs(err_pan_position) >= ptu_err_threshold) || (fabs(err_tilt_position) >= ptu_err_threshold))
    {
        ROS_WARN("bad ptuController tracking: err pan %6.2f err tilt %6.2f", err_pan_position, err_tilt_position);

        /*
        std::sstream ss;
        ss << "bad ptuController tracking: err pan= " << err_pan_position << " err tilt= " << err_tilt_position
           << " at time " << ros::Time::now();
        std_msgs::String msg; msg.data = ss.c_str();
        */
        std_msgs::String msg;
        msg.data = "bad ptuController tracking!";
        diagnosticPublisher.publish(msg);
    }
    pthread_mutex_unlock(&mutex);
}

/**
 * called when the Jaco arm trajectory controller publishes new state data.
 */
void DoroWatchdog::armControllerStateCallback(const control_msgs::JointTrajectoryControllerState armState)
{
    // if (debug) ROS_INFO( "DJSM.armControllerStateCallback %p", &armState );
    n_arm_controller_callbacks++;
    if (n_arm_controller_callbacks < 5)
    {
        ROS_INFO("DJSM.ptuUpdatedCallback %p", &armState);
    }

    pthread_mutex_lock(&mutex);

    double jointAngleThreshold = 0.01;
    bool ok = true;
    for (int j = 0; j < 6; j++)
    {
        if (fabs(armState.error.positions[j]) >= jointAngleThreshold)
            ok = false;
    }

    if (!ok)
    {
        ROS_WARN("bad Jaco arm tracking, position errors are %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f",
                 armState.error.positions[0], armState.error.positions[1], armState.error.positions[2],
                 armState.error.positions[3], armState.error.positions[4], armState.error.positions[5]);

        std_msgs::String msg;
        msg.data = "bad Jaco arm controller tracking!";
        diagnosticPublisher.publish(msg);
    }
    pthread_mutex_unlock(&mutex);
}

void DoroWatchdog::finger1ControllerStateCallback(const control_msgs::JointTrajectoryControllerState fingerState)
{
}

void DoroWatchdog::finger2ControllerStateCallback(const control_msgs::JointTrajectoryControllerState fingerState)
{
}

void DoroWatchdog::finger3ControllerStateCallback(const control_msgs::JointTrajectoryControllerState fingerState)
{
}

/**
 * called by our internal timer. We take the latest values received
 * from the different components, and publish our /joint_state message.
 */
void DoroWatchdog::timerCallback(const ros::TimerEvent& timerEvent)
{
    // TimerEvent :->  Time ->sec,nscec
    n_timer_callbacks++;
    if ((n_timer_callbacks < 5) || ((n_timer_callbacks % (60 * 100)) == 0))
    {  // once per minute at 100Hz
        ROS_INFO("DSJM timerCallback at %d, %d", timerEvent.current_real.sec, n_timer_callbacks);
    }
}

/**
 * starts the joint-state merger.
 */
int main(int argc, char** argv)
{
    ros::init(argc, argv, "doro_watchdog", 1);  // 1 means no NoSigintHandler
    // ros::init_options::InitOption.NoSigintHandler );

    DoroWatchdog watchdog = DoroWatchdog();

    ROS_INFO("DoroWatchdog: entering spin()...");

    while (ros::ok())
    {
        ros::spinOnce();
        usleep(100 * 1000);
    }
    exit(0);
}
