#!/usr/bin/env python

import rospy
import control_msgs.msg
import trajectory_msgs.msg
import numpy as np
import sensor_msgs.msg


class TeachMode:
    def __init__(self):
        dtime = 0.015
        torque_max = 20.0
        torque_threshold = 1.0
        diff_max = 2.0
        diff_threshold = 0.005
        v_threshold = 0.0
        torque_speed = 0.05
        diff_speed = 0.0
        torque_gains = np.array([1, 0.2, 1, 1, 5, 5, 10])
        fps = 100
        rrate = rospy.Rate(fps)
        self.controller_state = None
        self.joint_torques = None
        self.position = None
        self.last_position = None
        rospy.Subscriber("/lwr/state", control_msgs.msg.JointTrajectoryControllerState,
                         self.controller_state_callback)
        rospy.Subscriber("/lwr/joint_states", sensor_msgs.msg.JointState, self.joint_state_callback)
        publisher = rospy.Publisher("lwr/command", trajectory_msgs.msg.JointTrajectory, queue_size=10)
        msg = None
        while not rospy.is_shutdown():
            rrate.sleep()
            if self.controller_state is None:
                print("waiting for controller")
                continue
            if self.joint_torques is None:
                print("waiting for torques")
                continue
            if msg is None:
                print("running")
                msg = trajectory_msgs.msg.JointTrajectory()
                msg.joint_names = self.controller_state.joint_names
                msg.points.append(trajectory_msgs.msg.JointTrajectoryPoint())
                msg.points[-1].positions = list(self.controller_state.desired.positions)
                msg.points[-1].time_from_start = rospy.rostime.Duration.from_sec(dtime)

            diffs = np.array(self.controller_state.error.positions)

            for i in range(len(diffs)):
                if np.abs(diffs[i]) >= diff_max:
                    print("diffs[{}] is {}, diff max is {}".format(i, np.abs(diffs[i]), diff_max))
                    print("ERROR")
                    exit(0)
                diffs[i] = min(diff_max, max(0.0, (np.abs(diffs[i]) - diff_threshold))) * np.sign(diffs[i])

            torques = np.array(self.joint_torques)
            for i in range(len(torques)):
                torques[i] = (min(torque_max, max(0.0, (np.abs(torques[i]) - torque_threshold)))
                              * np.sign(torques[i]) * torque_gains[i])
            velocities = torques * torque_speed + diffs * diff_speed
            velocities = np.maximum(velocities * 0.0, np.abs(velocities) - v_threshold) * np.sign(velocities)
            self.position = np.array(msg.points[-1].positions) - velocities * 1.0 / fps
            msg.points[-1].positions = list(self.position)
            if self.last_position is not None:
                rospy.loginfo("distance to last position {} in degree".
                              format(np.round(np.rad2deg(self.position-self.last_position), 5)))
            self.last_position = self.position
            publisher.publish(msg)

    def controller_state_callback(self, msg):
        self.controller_state = msg

    def joint_state_callback(self, msg):
        self.joint_torques = msg.effort


if __name__ == "__main__":
    rospy.init_node("lwr_teleop")
    TeachMode()
