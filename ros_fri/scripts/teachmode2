#!/usr/bin/env python

import curses
import rospy
import re
import os
import sys
import control_msgs.msg
import trajectory_msgs.msg
import random
import math
import numpy as np
import sensor_msgs.msg

dtime = 0.01

torque_max = 20.0
torque_threshold = 1.0

diff_max = 2.0
diff_threshold = 0.005

# torque_threshold = 0.0
# diff_threshold = 0.0

v_threshold = 0.0

torque_speed = 0.1
diff_speed = 0.0

torque_gains = [
    1,
    1,
    1,
    1,
    5,
    5,
    10,
]

velocities = False

controller_name = "/lwr"

rospy.init_node("lwr_teleop")
rate = rospy.Rate(100)

joint_torques = False

controller_state = False


def controller_state_collback(msg):
    global controller_state
    controller_state = msg


rospy.Subscriber(
    controller_name + "/state",
    control_msgs.msg.JointTrajectoryControllerState,
    controller_state_collback,
)


def joint_state_callback(msg):
    global joint_torques
    joint_torques = msg.effort


rospy.Subscriber("/joint_states", sensor_msgs.msg.JointState, joint_state_callback)


publisher = rospy.Publisher(
    controller_name + "/command", trajectory_msgs.msg.JointTrajectory, queue_size=10
)

fps = 500
frametime = 1.0 / fps

rrate = rospy.Rate(fps)

msg = False

iterations = 0
start_time = rospy.get_time()

velocities2 = False

scalar_velocity = 0.0


def mix(a, b, f):
    return a * (1 - f) + b * f


while not rospy.is_shutdown():

    iterations = iterations + 1

    rrate.sleep()

    state = controller_state

    if state is False:
        print("waiting for controller")
        continue

    torques = joint_torques
    if torques is False:
        print("waiting for torques")
        continue

    if msg is False:
        print("running")
        msg = trajectory_msgs.msg.JointTrajectory()
        msg.joint_names = state.joint_names
        msg.points.append(trajectory_msgs.msg.JointTrajectoryPoint())
        msg.points[-1].positions = list(state.desired.positions)
        msg.points[-1].time_from_start = rospy.rostime.Duration.from_sec(dtime)
        velocities = np.zeros(len(state.desired.positions))
        velocities2 = np.zeros(len(state.desired.positions))

    if True:
        msg2 = trajectory_msgs.msg.JointTrajectory()
        msg2.joint_names = msg.joint_names
        msg2.points = msg.points
        msg = msg2

    # print iterations, rospy.get_time() - start_time

    names = state.joint_names
    diffs = np.array(state.error.positions)

    if False:
        for i in range(len(diffs)):
            print(names[i], diffs[i])

    for i in range(len(diffs)):
        if np.abs(diffs[i]) >= diff_max:
            print("ERROR")
            exit(0)
        diffs[i] = min(
            diff_max, max(0.0, (np.abs(diffs[i]) - diff_threshold))
        ) * np.sign(diffs[i])

    if False:
        for i in range(len(diffs)):
            print(names[i], diffs[i])

    torques = np.array(torques)
    for i in range(len(torques)):
        torques[i] = (
            min(torque_max, max(0.0, (np.abs(torques[i]) - torque_threshold)))
            * np.sign(torques[i])
            * torque_gains[i]
        )
    velocities = torques * torque_speed + diffs * diff_speed

    # print velocities

    # if np.linalg.norm(velocities) < v_threshold:
    #    velocities = velocities * 0.0

    velocities = np.maximum(
        velocities * 0.0, np.abs(velocities) - v_threshold
    ) * np.sign(velocities)

    """
    v = np.linalg.norm(velocities)
    if v < scalar_velocity:
        scalar_velocity = v
    else:
        scalar_velocity = mix(v, scalar_velocity, pow(0.5, frametime))
    if v > 0.0:
        velocities /= v
    velocities = velocities * scalar_velocity
    """

    """
    for i in xrange(len(torques)):
        if abs(velocities[i]) > abs(velocities2[i]):
            velocities2[i] = mix(velocities[i], velocities2[i], pow(0.5, frametime))
        else:
            velocities2[i] = velocities[i]
    velocities = velocities2
    """

    # print velocities

    if True:
        # msg.points[-1].positions = list(np.array(msg.points[-1].positions) - np.array(diffs))
        msg.points[-1].positions = list(
            np.array(msg.points[-1].positions) - velocities * frametime
        )
        publisher.publish(msg)
        # print msg
